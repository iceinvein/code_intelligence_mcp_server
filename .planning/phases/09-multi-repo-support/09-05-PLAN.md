---
phase: 09-multi-repo-support
plan: 05
type: execute
wave: 3
depends_on: [09-04]
files_modified:
  - src/storage/sqlite/queries/packages.rs
  - src/retrieval/ranking/package.rs
  - src/retrieval/ranking/mod.rs

autonomous: true

must_haves:
  truths:
    - "Package IDs can be looked up for multiple symbols efficiently"
    - "Same-package results receive ranking boost based on intent"
    - "Package boost is integrated with hit_signals tracking"
  artifacts:
    - path: "src/storage/sqlite/queries/packages.rs"
      provides: "Batch package lookup for symbols"
      exports: ["batch_get_symbol_packages", "get_package_id_for_file"]
    - path: "src/retrieval/ranking/package.rs"
      provides: "Same-package scoring boost function"
      exports: ["apply_package_boost_with_signals"]
      min_lines: 80
  key_links:
    - from: "src/retrieval/ranking/package.rs"
      to: "src/storage/sqlite/queries/packages.rs"
      via: "batch_get_symbol_packages for package lookup"
      pattern: "batch_get_symbol_packages"
    - from: "src/retrieval/ranking/package.rs"
      to: "hit_signals"
      via: "package_boost field added to signals"
      pattern: "hit_signals\\.package_boost"
---

<objective>
Implement SQLite batch package queries and package-aware ranking module

**Purpose:** Create efficient batch lookup for package associations and implement the core ranking algorithm that boosts same-package search results based on query intent (navigation vs generic search).

**Output:**
- Batch package lookup query for symbol-to-package association
- Package ID lookup for file paths
- Same-package scoring algorithm with intent-aware multipliers
- Integration with existing hit_signals pattern
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md

@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/phases/09-multi-repo-support/09-CONTEXT.md
@.planning/phases/09-multi-repo-support/09-RESEARCH.md

@.planning/phases/09-multi-repo-support/09-04-SUMMARY.md

@src/storage/sqlite/queries/packages.rs
@src/storage/sqlite/queries/metrics.rs
@src/retrieval/ranking/score.rs
@src/retrieval/ranking/mod.rs
</context>

<context>
## Existing Batch Query Patterns

From src/storage/sqlite/queries/metrics.rs, batch_get_symbol_metrics provides the pattern:
```rust
pub fn batch_get_symbol_packages(conn: &Connection, symbol_ids: &[&str]) -> Result<HashMap<String, String>>
```
Uses IN clause with rusqlite's params_from_iter for efficient batch lookup.

## Existing Ranking Patterns

From src/retrieval/ranking/score.rs:
- apply_popularity_boost_with_signals: Batch lookup + HashMap result + boost application + hit_signals update + re-sort
- apply_file_affinity_boost_with_signals: File-based boost with normalization

All ranking functions follow the same pattern:
1. Collect IDs/keys from hits
2. Batch lookup from SQLite
3. Apply boost to hits
4. Update hit_signals
5. Re-sort by score

## Intent Types

From src/retrieval/query.rs:
- Navigation: Definition, Implementation, Reference (higher boost)
- Generic: General, Error (lower boost)
- Other: Schema, Type, etc. (medium boost)

## Key Decisions from CONTEXT.md

Same-package scoring multipliers:
- Navigation intents (Definition, Reference, Implementation): 1.2x
- Generic search (General, Error): 1.1x
- Other intents: 1.15x

## Discovery Level: Level 0 (Skip)

All work follows established patterns:
- Batch query patterns from metrics.rs
- Ranking signal patterns from score.rs
- No new external dependencies
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add batch package lookup to SQLite queries</name>
  <files>src/storage/sqlite/queries/packages.rs</files>
  <action>
Update src/storage/sqlite/queries/packages.rs with:

batch_get_symbol_packages(conn: &Connection, symbol_ids: &[&str]) -> Result<HashMap<String, String>>
- Query: SELECT s.id, p.id FROM symbols s JOIN packages p ON s.file_path LIKE p.manifest_path || '%' WHERE s.id IN (...)
- Build IN clause dynamically based on symbol_ids length
- Use rusqlite's params_from_iter for parameter binding
- Returns HashMap<symbol_id, package_id>
- Follow exact pattern of batch_get_symbol_metrics in metrics.rs

get_package_id_for_file(conn: &Connection, file_path: &str) -> Result<Option<String>>
- Reuse get_package_for_file logic but return only package_id as String
- Query: SELECT id FROM packages WHERE ?1 LIKE manifest_path || '%' ORDER BY LENGTH(manifest_path) DESC LIMIT 1
- Returns Ok(Some(package_id)) or Ok(None)

Include unit tests:
- test_batch_get_symbol_packages_returns_map()
- test_get_package_id_for_file_finds_containing_package()
  </action>
  <verify>cargo test batch_get_symbol_packages passes</verify>
  <done>Package IDs can be looked up for multiple symbols efficiently</done>
</task>

<task type="auto">
  <name>Task 2: Create package-aware ranking module</name>
  <files>src/retrieval/ranking/package.rs, src/retrieval/ranking/mod.rs</files>
  <action>
Create src/retrieval/ranking/package.rs with:

apply_package_boost_with_signals(
    sqlite: &Storage,
    hits: Vec<RankedHit>,
    hit_signals: &mut [HitSignals],
    query_package_id: Option<&str>,
    config: &Config,
    intent: Intent
) -> Result<Vec<RankedHit>>

Algorithm:
1. Determine query context package:
   - If query_package_id is Some(), use it
   - Else auto-detect from first hit's file_path using get_package_id_for_file
2. Collect all symbol IDs from hits
3. Batch lookup package_id for all hits using batch_get_symbol_packages
4. Determine boost multiplier based on intent:
   - Navigation (Definition, Implementation, Reference): 1.2
   - Generic (General, Error): 1.1
   - Others: 1.15
5. For each hit where hit_package_id == query_package_id:
   - Apply multiplier: hit.score * boost
   - Update hit_signals[index].package_boost = boost_amount
6. Re-sort hits by updated score
7. Return re-sorted hits

Follow exact pattern of apply_file_affinity_boost_with_signals from score.rs

Update src/retrieval/ranking/mod.rs:
- Add: pub mod package;
- Re-export: pub use package::apply_package_boost_with_signals;

Include tests:
- test_same_package_boost_prioritizes_same_package()
- test_cross_package_no_boost_applied()
- test_intent_affects_boost_multiplier()
  </action>
  <verify>cargo test apply_package_boost passes</verify>
  <done>Same-package results are boosted in ranking based on intent</done>
</task>

</tasks>

<verification>
1. Create test data with symbols from multiple packages
2. Run cargo test batch_get_symbol_packages
3. Verify HashMap returns correct symbol->package mappings
4. Run cargo test apply_package_boost_with_signals
5. Verify same-package hits receive higher scores
6. Verify different intents produce different boost amounts
</verification>

<success_criteria>
- batch_get_symbol_packages returns correct package mappings
- get_package_id_for_file finds containing package
- Same-package hits receive higher scores after ranking
- Boost multiplier varies by intent type
- hit_signals.package_boost reflects applied boost
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/09-multi-repo-support/09-05-SUMMARY.md`
</output>
